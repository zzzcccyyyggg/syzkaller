// For some context need to synchronize on fuzzer and executor
#include <stdint.h>
#include <stdbool.h>

#ifdef __cplusplus
extern "C" {
#endif

// Should match the MaxAccessHistoryRecords in pkg/ddrd/types.go
#define MAX_ACCESS_HISTORY_RECORDS 100  // 限制每个线程的访问历史记录数量，避免共享内存溢出

// LockStatus 已在 types.h 中定义，此处不再重复定义

// for transmit the race pair information from executor to fuzzer
// which i think should be same with the MayRacePair in the /pkg/ddrd/types.go 
typedef struct {
	// Extended metadata from executor - leading uint64 fields
	uint64_t varName1;   // First variable name identifier
	uint64_t varName2;   // Second variable name identifier
	uint64_t call_stack1; // Callstack hash for first access
	uint64_t call_stack2; // Callstack hash for second access
	uint64_t signal;     // Race signal generated by executor (based on varname1+varname2+callstack hashes)
	uint64_t time_diff;    // Time difference between accesses (nanoseconds)
	// Core race information and sequence numbers
	int sn1;
	int sn2;
	int syscall1_idx; // First syscall in the race pair
	int syscall2_idx; // Second syscall in the race pair
	int syscall1_num;
	int syscall2_num;
	// Thread information
	int tid1;            // Thread ID for first access
	int tid2;            // Thread ID for second access
	// Additional context
	uint32_t lock_type;    // Lock type (e.g., mutex, rwlock)
	uint32_t access_type1; // First access type (read/write/free)
	uint32_t access_type2; // Second access type (read/write/free)
} may_race_pair_t;

// for transmit the UAF pair information from executor to fuzzer
typedef struct {
	// Extended metadata from executor - leading uint64 fields
	uint64_t free_access_name;    // Free access name identifier
	uint64_t use_access_name;     // Use access name identifier
	uint64_t free_call_stack;     // Callstack hash for free operation
	uint64_t use_call_stack;      // Callstack hash for use operation
	uint64_t signal;              // UAF signal generated by executor
	uint64_t time_diff;           // Time difference between free and use (nanoseconds)
	// Core UAF information
	int free_syscall_idx;         // Syscall index where free operation occurred
	int use_syscall_idx;          // Syscall index where use operation occurred
	int free_syscall_num;         // Syscall number for free operation
	int use_syscall_num;          // Syscall number for use operation
	int free_sn;                  // Sequence number for free operation
	int use_sn;                   // Sequence number for use operation
	// Thread information
	int free_tid;                 // Thread ID for free operation
	int use_tid;                  // Thread ID for use operation
	// Additional context
	uint32_t lock_type;           // Lock status between free and use
	uint32_t use_access_type;     // Use access type (read/write)
} may_uaf_pair_t;

// 历史访问记录的序列化格式（用于共享内存传输）
typedef struct {
	uint64_t var_name;              // 变量名哈希
	uint64_t call_stack_hash;       // 调用栈哈希
	uint64_t access_time;           // 访问时间 (nanoseconds since boot)
	uint32_t sn;                    // 序列号
	uint32_t access_type;           // 访问类型：'R'=读, 'W'=写, 'F'=释放
} serialized_access_record_t;

// 扩展的race pair信息，直接包含历史访问数据
typedef struct {
	may_race_pair_t basic_info;     // 基本race信息
	uint32_t thread1_history_count; // 线程1历史访问数量
	uint32_t thread2_history_count; // 线程2历史访问数量
	uint64_t thread1_target_time;   // 线程1目标事件时间
	uint64_t thread2_target_time;   // 线程2目标事件时间
	double path_distance1;          // 线程1的路径距离
	double path_distance2;          // 线程2的路径距离
	// 历史访问数据直接嵌入（可变长度）
	// thread1_history_count 个 serialized_access_record_t 记录
	// 然后是 thread2_history_count 个 serialized_access_record_t 记录
	serialized_access_record_t access_history[];  // 柔性数组成员
} extended_race_pair_t;

// 扩展的UAF pair信息，直接包含历史访问数据
typedef struct {
	may_uaf_pair_t basic_info;      // 基本UAF信息
	uint32_t use_thread_history_count;  // Use线程历史访问数量
	uint32_t free_thread_history_count; // Free线程历史访问数量
	uint64_t use_target_time;       // Use事件目标时间
	uint64_t free_target_time;      // Free事件目标时间
	double path_distance_use;       // Use线程的路径距离
	double path_distance_free;      // Free线程的路径距离
	// 历史访问数据直接嵌入（可变长度）
	// use_thread_history_count 个 serialized_access_record_t 记录
	// 然后是 free_thread_history_count 个 serialized_access_record_t 记录
	serialized_access_record_t access_history[];  // 柔性数组成员
} extended_uaf_pair_t;


#ifdef __cplusplus
}
#endif