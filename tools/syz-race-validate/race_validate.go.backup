// Copyright 2025 syzkaller project authors. All rights reserved.
// Use of this source code is governed by Apache 2 LICENSE that can be found in the LICENSE file.

package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"time"

	"github.com/google/syzkaller/pkg/db"
	"github.com/google/syzkaller/pkg/host"
	"github.com/google/syzkaller/pkg/log"
	"github.com/google/syzkaller/pkg/mgrconfig"
	"github.com/google/syzkaller/pkg/osutil"
	"github.com/google/syzkaller/pkg/racevalidate"
	"github.com/google/syzkaller/pkg/report"
	"github.com/google/syzkaller/pkg/vm"
	"github.com/google/syzkaller/prog"
)

// ExecutionRecord represents a single VM execution record
type ExecutionRecord struct {
	SeqID     int    `json:"seq_id"`
	CallNum   int    `json:"call_num"`
	Duration  int64  `json:"duration"`
	Timestamp int64  `json:"timestamp"`
	Metadata  string `json:"metadata,omitempty"`
}

// ExecutionContext represents the VM execution sequence context
type ExecutionContext struct {
	PairID   string             `json:"pair_id"`
	Records  []ExecutionRecord  `json:"records"`
	Metadata map[string]string  `json:"metadata,omitempty"`
}

// UAFCorpusItem represents a UAF pair item in the corpus
type UAFCorpusItem struct {
	PairID           string    `json:"pair_id"`
	Prog1            []byte    `json:"prog1"`
	Prog2            []byte    `json:"prog2"`
	UAFSignal        []byte    `json:"uaf_signal"`        // serialized UAF signal
	UAFs             []byte    `json:"uafs"`              // serialized []ddrd.MayUAFPair
	Output           []byte    `json:"output"`            // execution output for debugging
	ExecutionContext []byte    `json:"execution_context"` // serialized execution sequence context
	FirstSeen        time.Time `json:"first_seen"`
	LastUpdated      time.Time `json:"last_updated"`
	Source           string    `json:"source"`             // source fuzzer name
	LogPath          string    `json:"log_path,omitempty"` // path to log file for reproduction
	Count            int       `json:"count"`              // discovery count
}

// loadUAFCorpus loads UAF corpus from database and prints execution contexts
	"github.com/google/syzkaller/pkg/log"
	"github.com/google/syzkaller/pkg/mgrconfig"
	"github.com/google/syzkaller/pkg/osutil"
	"github.com/google/syzkaller/pkg/racevalidate"
	"github.com/google/syzkaller/pkg/report"
	"github.com/google/syzkaller/prog"
	"github.com/google/syzkaller/vm"
)

// UAFCorpusItem represents a UAF pair item in the corpus (mirrors manager's definition)
type UAFCorpusItem struct {
	PairID           string    `json:"pair_id"`
	Prog1            []byte    `json:"prog1"`
	Prog2            []byte    `json:"prog2"`
	UAFSignal        []byte    `json:"uaf_signal"`        // serialized UAF signal
	UAFs             []byte    `json:"uafs"`              // serialized []ddrd.MayUAFPair
	Output           []byte    `json:"output"`            // execution output for debugging
	ExecutionContext []byte    `json:"execution_context"` // serialized execution sequence context
	FirstSeen        time.Time `json:"first_seen"`
	LastUpdated      time.Time `json:"last_updated"`
	Source           string    `json:"source"`             // source fuzzer name
	LogPath          string    `json:"log_path,omitempty"` // path to log file for reproduction
	Count            int       `json:"count"`              // discovery count
}

// loadUAFCorpusStats loads and displays UAF corpus statistics
func loadUAFCorpusStats(corpusPath string) (int, error) {
	uafCorpusDB, err := db.Open(corpusPath, false)
	if err != nil {
		return 0, fmt.Errorf("failed to open UAF corpus database: %v", err)
	}
	// Note: db.DB doesn't have Close method, just let it be garbage collected

	fmt.Printf("UAF Corpus Statistics:\n")
	fmt.Printf("  Corpus location: %s\n", corpusPath)
	fmt.Printf("  Total UAF pairs: %d\n", len(uafCorpusDB.Records))

	// Analyze UAF pairs
	validPairs := 0
	brokenPairs := 0
	totalExecutionContexts := 0

	for key, rec := range uafCorpusDB.Records {
		var item UAFCorpusItem
		if err := json.Unmarshal(rec.Val, &item); err != nil {
			log.Logf(1, "Failed to unmarshal UAF corpus item %s: %v", key, err)
			brokenPairs++
			continue
		}
		validPairs++
		
		if len(item.ExecutionContext) > 0 {
			totalExecutionContexts++
		}
		
		// Log first few items for debugging
		if validPairs <= 3 {
			log.Logf(1, "UAF pair sample: ID=%s, Count=%d, HasExecContext=%t", 
				item.PairID, item.Count, len(item.ExecutionContext) > 0)
		}
	}

	fmt.Printf("  Valid UAF pairs: %d\n", validPairs)
	fmt.Printf("  Broken UAF pairs: %d\n", brokenPairs)
	fmt.Printf("  Pairs with execution context: %d\n", totalExecutionContexts)
	if validPairs > 0 {
		fmt.Printf("  Execution context coverage: %.2f%%\n", float64(totalExecutionContexts)/float64(validPairs)*100)
	}
	fmt.Printf("\n")

	return validPairs, nil
}

var (
	flagConfig    = flag.String("config", "", "manager configuration file (manager.cfg)")
	flagCorpus    = flag.String("corpus", filepath.Join("uaf-corpus.db"), "UAF corpus database file (uaf-corpus.db)")
	flagUAFCorpus = flag.String("uaf-corpus", filepath.Join("uaf-corpus.db"), "UAF corpus database file (uaf-corpus.db)")
	flagCount     = flag.Int("count", 0, "number of VMs to use (overrides config count param)")
	flagVerbose   = flag.Bool("verbose", false, "print verbose output")
	flagAttempts  = flag.Int("attempts", 3, "number of validation attempts per race")
	flagOutput    = flag.String("output", filepath.Join("uaf-validation-results.txt"), "output results file")
	flagWorkdir   = flag.String("workdir", "", "working directory (for validation database), defaults to config workdir")
	flagForce     = flag.Bool("force", false, "force re-validation of already validated pairs (not implemented)")
	flagStatsOnly = flag.Bool("stats-only", false, "only show validation database statistics without running validation")
	flagHelp      = flag.Bool("help", false, "show detailed usage information")
	flagValidateUAF = flag.Bool("validate-uaf", true, "validate UAF pairs instead of race pairs (default: true)")
	// Path-distance-aware scheduling options
	flagPathAware      = flag.Bool("path-aware", false, "enable path-distance-aware scheduling for better race reproduction")
	flagMaxDelay       = flag.Int("max-delay", 1000, "maximum delay injection in microseconds (default: 1000)")
	flagCollectHistory = flag.Bool("collect-history", false, "collect and use access history for delay injection")
)

func usage() {
	fmt.Fprintf(os.Stderr, "syz-race-validate: validates UAF pairs and race conditions from corpus databases\n\n")
	fmt.Fprintf(os.Stderr, "This tool validates UAF pairs and race conditions found in the corpus databases,\n")
	fmt.Fprintf(os.Stderr, "automatically skipping pairs that have already been validated.\n")
	fmt.Fprintf(os.Stderr, "Primary focus is on UAF validation with detailed execution context analysis.\n\n")
	fmt.Fprintf(os.Stderr, "UAF Execution Context Analysis:\n")
	fmt.Fprintf(os.Stderr, "The tool displays detailed execution flow information for each UAF pair,\n")
	fmt.Fprintf(os.Stderr, "including syscall sequences and timing information.\n\n")
	fmt.Fprintf(os.Stderr, "Usage:\n")
	fmt.Fprintf(os.Stderr, "  # Validate UAF pairs (default)\n")
	fmt.Fprintf(os.Stderr, "  %s -config=manager.cfg -corpus=uaf-corpus.db [options]\n\n", os.Args[0])
	fmt.Fprintf(os.Stderr, "  # Validate race pairs\n")
	fmt.Fprintf(os.Stderr, "  %s -config=manager.cfg -corpus=race-corpus.db -validate-uaf=false [options]\n\n", os.Args[0])
	fmt.Fprintf(os.Stderr, "Examples:\n")
	fmt.Fprintf(os.Stderr, "  # Basic UAF validation (default)\n")
	fmt.Fprintf(os.Stderr, "  %s -config=my.cfg -corpus=workdir/uaf-corpus.db\n\n", os.Args[0])
	fmt.Fprintf(os.Stderr, "  # UAF validation with execution flow analysis\n")
	fmt.Fprintf(os.Stderr, "  %s -config=my.cfg -corpus=workdir/uaf-corpus.db -verbose\n\n", os.Args[0])
	fmt.Fprintf(os.Stderr, "  # Auto-locate UAF corpus in workdir (if using default name)\n")
	fmt.Fprintf(os.Stderr, "  %s -config=my.cfg\n\n", os.Args[0])
	fmt.Fprintf(os.Stderr, "  # Show only UAF database statistics with execution contexts\n")
	fmt.Fprintf(os.Stderr, "  %s -config=my.cfg -corpus=workdir/uaf-corpus.db -stats-only\n\n", os.Args[0])
	fmt.Fprintf(os.Stderr, "  # Race validation (alternative mode)\n")
	fmt.Fprintf(os.Stderr, "  %s -config=my.cfg -corpus=workdir/race-corpus.db -validate-uaf=false\n\n", os.Args[0])
	fmt.Fprintf(os.Stderr, "  # Use fewer VMs and more attempts for UAF validation\n")
	fmt.Fprintf(os.Stderr, "  %s -config=my.cfg -corpus=workdir/uaf-corpus.db -count=2 -attempts=5\n\n", os.Args[0])
	fmt.Fprintf(os.Stderr, "Options:\n")
	flag.PrintDefaults()
	fmt.Fprintf(os.Stderr, "\nCorpus Auto-location:\n")
	fmt.Fprintf(os.Stderr, "  If -corpus is not specified or uses the default name 'uaf-corpus.db',\n")
	fmt.Fprintf(os.Stderr, "  the tool will automatically look for it in the workdir.\n")
	fmt.Fprintf(os.Stderr, "  Auto-location path: {workdir}/race-corpus.db\n")
	fmt.Fprintf(os.Stderr, "  If -uaf-corpus is not specified or uses the default name 'uaf-corpus.db',\n")
	fmt.Fprintf(os.Stderr, "  the tool will automatically look for it in the workdir.\n")
	fmt.Fprintf(os.Stderr, "  Auto-location path: {workdir}/uaf-corpus.db\n\n")
	fmt.Fprintf(os.Stderr, "Validation Database:\n")
	fmt.Fprintf(os.Stderr, "  The tool maintains validation databases to track which pairs have been\n")
	fmt.Fprintf(os.Stderr, "  validated, preventing duplicate work.\n")
	fmt.Fprintf(os.Stderr, "  Race validation: {workdir}/race_validated.db\n")
	fmt.Fprintf(os.Stderr, "  UAF validation: {workdir}/uaf_validated.db\n\n")
}

func main() {
	flag.Usage = usage
	flag.Parse()

	if *flagHelp {
		usage()
		return
	}

	if *flagConfig == "" {
		fmt.Fprintf(os.Stderr, "Error: -config is required\n\n")
		usage()
		os.Exit(1)
	}

	cfg, err := mgrconfig.LoadFile(*flagConfig)
	if err != nil {
		log.Fatalf("Failed to load config %v: %v", *flagConfig, err)
	}

	// Override workdir if specified
	workdir := cfg.Workdir
	if *flagWorkdir != "" {
		workdir = *flagWorkdir
		cfg.Workdir = workdir
	}

	// Determine which corpus to validate
	var corpusPath string
	var validateUAF bool = *flagValidateUAF

	if validateUAF {
		// Auto-locate UAF corpus in workdir if using default name
		if *flagUAFCorpus == "uaf-corpus.db" && workdir != "" {
			workdirCorpus := filepath.Join(workdir, "uaf-corpus.db")
			if osutil.IsExist(workdirCorpus) {
				*flagUAFCorpus = workdirCorpus
				log.Logf(1, "Auto-located UAF corpus in workdir: %s", workdirCorpus)
			}
		}
		corpusPath = *flagUAFCorpus
		if !osutil.IsExist(corpusPath) {
			log.Fatalf("UAF corpus file doesn't exist: %s", corpusPath)
		}
	} else {
		// Auto-locate race corpus in workdir if using default name
		if *flagCorpus == "race-corpus.db" && workdir != "" {
			workdirCorpus := filepath.Join(workdir, "race-corpus.db")
			if osutil.IsExist(workdirCorpus) {
				*flagCorpus = workdirCorpus
				log.Logf(1, "Auto-located race corpus in workdir: %s", workdirCorpus)
			}
		}
		corpusPath = *flagCorpus
		if !osutil.IsExist(corpusPath) {
			log.Fatalf("Race corpus file doesn't exist: %s", corpusPath)
		}
	}

	// Open validation database for statistics or force mode handling
	var validatedDB *racevalidate.ValidatedDB
	if validateUAF {
		// For now, use the same validation DB type for UAF
		// TODO: Implement separate UAF validation DB if needed
		validatedDB, err = racevalidate.OpenValidatedDB(workdir)
	} else {
		validatedDB, err = racevalidate.OpenValidatedDB(workdir)
	}
	if err != nil {
		log.Fatalf("Failed to open validation database: %v", err)
	}
	defer validatedDB.Close()

	// Show validation database statistics
	total, valid, invalid, err := validatedDB.GetValidationStats()
	if err != nil {
		log.Logf(0, "Warning: failed to get validation stats: %v", err)
	} else {
		fmt.Printf("Validation Database Statistics:\n")
		if validateUAF {
			fmt.Printf("  Database location: %s/uaf_validated.db\n", workdir)
			fmt.Printf("  Total validated UAF pairs: %d\n", total)
			fmt.Printf("  Valid UAF pairs: %d\n", valid)
			fmt.Printf("  Invalid UAF pairs: %d\n", invalid)
		} else {
			fmt.Printf("  Database location: %s/race_validated.db\n", workdir)
			fmt.Printf("  Total validated race pairs: %d\n", total)
			fmt.Printf("  Valid race pairs: %d\n", valid)
			fmt.Printf("  Invalid race pairs: %d\n", invalid)
		}
		if total > 0 {
			fmt.Printf("  Success rate: %.2f%%\n", float64(valid)/float64(total)*100)
		}
		fmt.Printf("\n")
	}

	// If only showing stats, show corpus stats and exit here
	if *flagStatsOnly {
		if validateUAF {
			_, err := loadUAFCorpusStats(corpusPath)
			if err != nil {
				log.Logf(0, "Warning: failed to load UAF corpus stats: %v", err)
			}
		} else {
			// Show race corpus stats (racevalidate package may have this functionality)
			fmt.Printf("Race Corpus Statistics:\n")
			fmt.Printf("  Corpus location: %s\n", corpusPath)
			fmt.Printf("  (Race corpus analysis would be implemented here)\n\n")
		}
		return
	}

	// Handle force mode - this would require clearing validation database
	// For now, just print a warning
	if *flagForce {
		fmt.Printf("Warning: Force mode is not yet implemented\n")
		fmt.Printf("To re-validate all pairs, manually delete: %s/race_validated.db\n\n", workdir)
	}

	// Create VM pool
	vmPool, err := vm.Create(cfg, *flagVerbose)
	if err != nil {
		log.Fatalf("Failed to create VM pool: %v", err)
	}
	defer vmPool.Close()

	vmCount := vmPool.Count()
	if *flagCount > 0 && *flagCount < vmCount {
		vmCount = *flagCount
	}
	if vmCount > 4 {
		vmCount = 4
	}

	vmIndexes := make([]int, vmCount)
	for i := range vmIndexes {
		vmIndexes[i] = i
	}
	reporter, err := report.NewReporter(cfg)
	if err != nil {
		log.Fatalf("Failed to create reporter: %v", err)
	}
	osutil.HandleInterrupts(vm.Shutdown)

	// Get target and host features
	target, err := prog.GetTarget(cfg.TargetOS, cfg.TargetArch)
	if err != nil {
		log.Fatalf("Failed to get target: %v", err)
	}

	hostFeatures, err := host.Check(target)
	if err != nil {
		log.Fatalf("Failed to check host features: %v", err)
	}

	if validateUAF {
		fmt.Printf("Starting UAF validation with %d VMs, %d attempts per UAF pair...\n", vmCount, *flagAttempts)
	} else {
		fmt.Printf("Starting race validation with %d VMs, %d attempts per race...\n", vmCount, *flagAttempts)
	}
	if *flagPathAware {
		fmt.Printf("Path-aware scheduling enabled: max-delay=%dms, collect-history=%v\n", *flagMaxDelay, *flagCollectHistory)
	}
	fmt.Printf("\n")

	// Run validation with path-aware options
	var results *racevalidate.Results
	var stats *racevalidate.Stats
	if validateUAF {
		// For now, use the same validation infrastructure for UAF
		// TODO: Implement dedicated UAF validation if needed
		if *flagPathAware {
			results, stats, err = racevalidate.RunWithOptions(corpusPath, cfg, hostFeatures, reporter, vmPool, vmIndexes, *flagAttempts, true, *flagMaxDelay, *flagCollectHistory)
		} else {
			results, stats, err = racevalidate.Run(corpusPath, cfg, hostFeatures, reporter, vmPool, vmIndexes, *flagAttempts)
		}
	} else {
		if *flagPathAware {
			results, stats, err = racevalidate.RunWithOptions(corpusPath, cfg, hostFeatures, reporter, vmPool, vmIndexes, *flagAttempts, true, *flagMaxDelay, *flagCollectHistory)
		} else {
			results, stats, err = racevalidate.Run(corpusPath, cfg, hostFeatures, reporter, vmPool, vmIndexes, *flagAttempts)
		}
	}
	if err != nil {
		if validateUAF {
			log.Logf(0, "UAF validation failed: %v", err)
		} else {
			log.Logf(0, "Race validation failed: %v", err)
		}
		os.Exit(1)
	}

	// Print timing statistics
	if stats != nil {
		fmt.Printf("Timing Statistics:\n")
		fmt.Printf("  Loading corpus: %v\n", stats.LoadCorpusTime)
		if validateUAF {
			fmt.Printf("  Validating UAFs: %v\n", stats.ValidateTime)
		} else {
			fmt.Printf("  Validating races: %v\n", stats.ValidateTime)
		}
		fmt.Printf("  Total time: %v\n", stats.TotalTime)
		fmt.Printf("\n")
	}

	if results == nil {
		if validateUAF {
			fmt.Printf("No UAF validation results\n")
		} else {
			fmt.Printf("No race validation results\n")
		}
		return
	}

	// Print validation results
	fmt.Printf("Validation Results:\n")
	if validateUAF {
		fmt.Printf("  Total UAF pairs attempted: %d\n", results.TotalRaces)
		fmt.Printf("  Confirmed UAF pairs: %d\n", results.ConfirmedRaces)
		fmt.Printf("  Failed UAF validations: %d\n", results.TotalRaces-results.ConfirmedRaces)
	} else {
		fmt.Printf("  Total races attempted: %d\n", results.TotalRaces)
		fmt.Printf("  Confirmed races: %d\n", results.ConfirmedRaces)
		fmt.Printf("  Failed validations: %d\n", results.TotalRaces-results.ConfirmedRaces)
	}

	// Print program pair analysis
	totalProgramPairs := 0
	racesWithLogs := 0
	for _, result := range results.RaceResults {
		if len(result.ProgramPairs) > 0 {
			racesWithLogs++
			totalProgramPairs += len(result.ProgramPairs)
		}
	}
	fmt.Printf("  Races with log files: %d\n", racesWithLogs)
	fmt.Printf("  Total program pairs found: %d\n", totalProgramPairs)

	// Calculate success rate for this run
	if results.TotalRaces > 0 {
		successRate := float64(results.ConfirmedRaces) / float64(results.TotalRaces) * 100
		fmt.Printf("  Success rate (this run): %.2f%%\n", successRate)
	}

	// Show updated database statistics
	totalAfter, validAfter, invalidAfter, err := validatedDB.GetValidationStats()
	if err == nil {
		fmt.Printf("\nUpdated Database Statistics:\n")
		fmt.Printf("  Total validated pairs: %d (was %d, +%d)\n", totalAfter, total, totalAfter-total)
		fmt.Printf("  Valid pairs: %d (was %d, +%d)\n", validAfter, valid, validAfter-valid)
		fmt.Printf("  Invalid pairs: %d (was %d, +%d)\n", invalidAfter, invalid, invalidAfter-invalid)
		if totalAfter > 0 {
			fmt.Printf("  Overall success rate: %.2f%%\n", float64(validAfter)/float64(totalAfter)*100)
		}
	}

	// Show sample of failed validations
	failedCount := 0
	fmt.Printf("\nFailed Validations (sample):\n")
	for _, result := range results.RaceResults {
		if !result.Confirmed && result.ErrorMsg != "" {
			failedCount++
			if failedCount <= 5 { // Show first 5 failures
				fmt.Printf("  %s: %s\n", result.PairID, result.ErrorMsg)
			}
		}
	}
	if failedCount > 5 {
		fmt.Printf("  ... and %d more failures (see output file for details)\n", failedCount-5)
	} else if failedCount == 0 {
		fmt.Printf("  None (all validations succeeded)\n")
	}

	// Save detailed results to file
	if err := saveResults(results, *flagOutput); err != nil {
		log.Logf(0, "Failed to save results: %v", err)
	} else {
		fmt.Printf("\nDetailed results saved to: %s\n", *flagOutput)
	}

	// Final summary
	fmt.Printf("\nSummary:\n")
	if results.TotalRaces == 0 {
		fmt.Printf("  No new race pairs to validate (all already validated)\n")
		fmt.Printf("  Use -stats-only to view database statistics\n")
	} else {
		fmt.Printf("  Validated %d race pairs in this run\n", results.TotalRaces)
		fmt.Printf("  Database now contains %d total validated pairs\n", totalAfter)
	}
}

func saveResults(results *racevalidate.Results, filename string) error {
	// Calculate program pair statistics
	totalProgramPairs := 0
	racesWithLogs := 0

	// Calculate UAF validation statistics
	totalUAFValidations := 0
	confirmedUAFs := 0
	totalUAFStages := 0
	totalUAFAttempts := 0

	for _, result := range results.RaceResults {
		if len(result.ProgramPairs) > 0 {
			racesWithLogs++
			totalProgramPairs += len(result.ProgramPairs)
		}

		// Collect UAF validation statistics
		if result.UAFValidation != nil {
			totalUAFValidations++
			if result.UAFValidation.Confirmed {
				confirmedUAFs++
			}
			totalUAFStages += result.UAFValidation.StagesAttempted
			totalUAFAttempts += result.UAFValidation.TotalAttempts
		}
	}

	// Create enhanced results with more metadata
	enhancedResults := map[string]interface{}{
		"summary": map[string]interface{}{
			"total_races":         results.TotalRaces,
			"confirmed_races":     results.ConfirmedRaces,
			"success_rate":        0.0,
			"races_with_logs":     racesWithLogs,
			"total_program_pairs": totalProgramPairs,
			// UAF validation summary
			"uaf_validations": map[string]interface{}{
				"total_validated":  totalUAFValidations,
				"confirmed":        confirmedUAFs,
				"uaf_success_rate": 0.0,
				"avg_stages":       0.0,
				"avg_attempts":     0.0,
			},
		},
		"results":   results.RaceResults,
		"timestamp": fmt.Sprintf("%v", os.Getpid()), // Simple timestamp alternative
	}

	if results.TotalRaces > 0 {
		enhancedResults["summary"].(map[string]interface{})["success_rate"] =
			float64(results.ConfirmedRaces) / float64(results.TotalRaces) * 100
	}

	// Calculate UAF-specific statistics
	uafSummary := enhancedResults["summary"].(map[string]interface{})["uaf_validations"].(map[string]interface{})
	if totalUAFValidations > 0 {
		uafSummary["uaf_success_rate"] = float64(confirmedUAFs) / float64(totalUAFValidations) * 100
		uafSummary["avg_stages"] = float64(totalUAFStages) / float64(totalUAFValidations)
		uafSummary["avg_attempts"] = float64(totalUAFAttempts) / float64(totalUAFValidations)
	}

	data, err := json.MarshalIndent(enhancedResults, "", "  ")
	if err != nil {
		return err
	}
	return osutil.WriteFile(filename, data)
}
