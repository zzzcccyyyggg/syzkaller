package ddrd

import (
	"github.com/google/syzkaller/pkg/hash"
)

// ⚠️ Alignment notes (64-bit platform):
// 1. 每个字段的地址必须是该字段大小的整数倍：
// 2. Go 会在必要时自动插入 padding，使后续字段满足对齐要求。
// 3. 整个 struct 的大小必须是最大对齐量的整数倍（这里是 8）。

// Should match the MAX_ACCESS_HISTORY_RECORDS in executor/ddrd.h
const (
	MaxAccessHistoryRecords = 100 // 限制每个线程的访问历史记录数量，避免共享内存溢出
)

// ExtendedUAFPair contains UAF information with access history
type ExtendedUAFPair struct {
	BasicInfo              MayUAFPair               // 基本UAF信息
	UseThreadHistoryCount  uint32                   // Use线程历史访问数量
	FreeThreadHistoryCount uint32                   // Free线程历史访问数量
	UseTargetTime          uint64                   // Use事件目标时间
	FreeTargetTime         uint64                   // Free事件目标时间
	AccessHistory          []SerializedAccessRecord // 历史访问记录（use记录 + free记录）
}

// ExtendedRacePair contains race information with access history
type ExtendedRacePair struct {
	BasicInfo           MayRacePair              // 基本race信息
	Thread1HistoryCount uint32                   // 线程1历史访问数量
	Thread2HistoryCount uint32                   // 线程2历史访问数量
	Thread1TargetTime   uint64                   // 线程1目标事件时间
	Thread2TargetTime   uint64                   // 线程2目标事件时间
	AccessHistory       []SerializedAccessRecord // 历史访问记录（thread1记录 + thread2记录）
}

// MayUAFPair represents a UAF pair transmitted from executor
// Totle size is 80
type MayUAFPair struct {
	FreeAccessName uint64 // Access1 name identifier 0
	UseAccessName  uint64 // Access2 name identifier 8
	FreeCallStack  uint64 // Callstack hash for free operation 16
	UseCallStack   uint64 // Callstack hash for use operation 24
	Signal         uint64 // UAF signal generated by executor 32
	TimeDiff       uint64 // Time difference between free and use (nanoseconds) 40
	FreeSyscallIdx int32  // Syscall index where free operation occurred 48
	UseSyscallIdx  int32  // Syscall index where use operation occurred	 52
	FreeSyscallNum int32  // Syscall number for free operation 56
	UseSyscallNum  int32  // Syscall number for use operation 60
	FreeSN         int32  // Sequence number for free operation 64
	UseSN          int32  // Sequence number for use operation 68
	LockType       uint32 // Lock status between free and use (e.g., mutex, rwlock) 72
	UseAccessType  uint32 // Use access type (read/write) 76
}

// MayRacePair represents a race condition pair transmitted from executor
// This structure MUST match exactly with may_race_pair_t in executor/ddrd.h
// CRITICAL: Keep field order and sizes EXACTLY matching the C struct!
// Alignment causes its size to be 88 bytes instead of the minimal 84 bytes.
type MayRacePair struct {
	VarName1    uint64 // First variable name identifier
	VarName2    uint64 // Second variable name identifier
	CallStack1  uint64 // Callstack hash for first access
	CallStack2  uint64 // Callstack hash for second access
	Signal      uint64 // Race signal generated by executor
	TimeDiff    uint64 // Time difference between accesses (nanoseconds)
	Sn1         int32  // Must match C struct field order
	Sn2         int32  // Must match C struct field order
	Syscall1Idx int32  // First syscall index in the race pair
	Syscall2Idx int32  // Second syscall index in the race pair
	Syscall1Num int32  // First syscall number
	Syscall2Num int32  // Second syscall number
	LockType    uint32 // Lock type (e.g., mutex, rwlock) - MUST be uint32 to match C
	AccessType1 uint32 // First access type (read/write/free) - MUST be uint32 to match C
	AccessType2 uint32 // Second access type (read/write/free) - MUST be uint32 to match C
}

// SerializedAccessRecord represents a serialized access record from shared memory
type SerializedAccessRecord struct {
	VarName       uint64 // 变量名哈希
	CallStackHash uint64 // 调用栈哈希
	AccessTime    uint64 // 访问时间 (nanoseconds since boot)
	SN            uint32 // 序列号
	AccessType    uint32 // 访问类型 (read/write/free)
}

// GeneratePairID creates a unique ID for a pair of prog1 and prog2
func GeneratePairID(Prog1, Prog2 []byte) uint64 {
	// Use a simple hash of the two programs
	h := hash.Hash(append(Prog1, Prog2...))
	// Convert first 8 bytes of hash to uint64
	var id uint64
	for i := 0; i < 8 && i < len(h); i++ {
		id = id<<8 | uint64(h[i])
	}
	return id
}
