package ddrd

import (
	"github.com/google/syzkaller/pkg/hash"
)

// MayRacePair represents a race condition pair transmitted from executor
// This structure MUST match exactly with may_race_pair_t in executor/ddrd.h
// CRITICAL: Keep field order and sizes EXACTLY matching the C struct!
type MayRacePair struct {
	// Core race information (4 bytes each) - MUST match C int size
	Syscall1Idx int32 // First syscall index in the race pair
	Syscall2Idx int32 // Second syscall index in the race pair
	Syscall1Num int32 // First syscall number
	Syscall2Num int32 // Second syscall number

	// Extended metadata from executor (8 bytes each)
	VarName1   uint64 // First variable name identifier
	VarName2   uint64 // Second variable name identifier
	CallStack1 uint64 // Callstack hash for first access
	CallStack2 uint64 // Callstack hash for second access

	// Keep same order as C struct
	Sn1    int32  // Must match C struct field order
	Sn2    int32  // Must match C struct field order
	Signal uint64 // Race signal generated by executor

	// Additional context - MUST match C struct sizes exactly
	LockType    uint32 // Lock type (e.g., mutex, rwlock) - MUST be uint32 to match C
	AccessType1 uint32 // First access type (read/write/free) - MUST be uint32 to match C
	AccessType2 uint32 // Second access type (read/write/free) - MUST be uint32 to match C

	TimeDiff uint64 // Time difference between accesses (nanoseconds)
}

// GeneratePairID creates a unique ID for a pair of prog1 and prog2
func GeneratePairID(Prog1, Prog2 []byte) uint64 {
	// Use a simple hash of the two programs
	h := hash.Hash(append(Prog1, Prog2...))
	// Convert first 8 bytes of hash to uint64
	var id uint64
	for i := 0; i < 8 && i < len(h); i++ {
		id = id<<8 | uint64(h[i])
	}
	return id
}
